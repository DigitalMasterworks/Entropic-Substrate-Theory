#!/usr/bin/env python3
# emit_bsd_ap_table_strict.py
# Strict emitter: fails on any non-integer entry.
# Reads JSON at JSON_PATH and writes ../BSD/Data.lean.

import json
from pathlib import Path
import datetime
import sys

JSON_PATH = Path("###/bsd_ap_table.json")
OUT_PATH = Path("../BSD/Data.lean")

def parse_strict_int(x, idx):
    # Accept only:
    #  - Python int
    #  - string that parses exactly to an int (e.g. "3", "-2")
    # Reject floats, None, lists, dicts, booleans, etc.
    if isinstance(x, int) and not isinstance(x, bool):
        return x
    if isinstance(x, str):
        s = x.strip()
        # allow optional leading +/-
        if s == "":
            raise ValueError(f"index {idx}: empty string is not an integer")
        try:
            # reject strings with decimal points
            if '.' in s or 'e' in s or 'E' in s:
                raise ValueError(f"index {idx}: string '{x}' looks like a non-integer numeric")
            return int(s)
        except ValueError:
            raise ValueError(f"index {idx}: string '{x}' cannot be parsed as int")
    # explicit rejection of floats to be strict
    raise ValueError(f"index {idx}: unexpected type {type(x).__name__} with value {repr(x)}; only integers or integer-strings allowed")

def locate_list(data):
    # If top-level list -> return it.
    if isinstance(data, list):
        return data
    if isinstance(data, dict):
        # common keys
        for k in ("ap_table","ap","values","a_p","a_p_table","data","values_list"):
            if k in data and isinstance(data[k], list):
                return data[k]
        # fallback: first value that is a list
        for v in data.values():
            if isinstance(v, list):
                return v
    raise RuntimeError("JSON format: expected top-level list or object containing a list under keys like 'ap_table' or 'ap'")

def main():
    if not JSON_PATH.exists():
        print(f"ERROR: JSON file not found at {JSON_PATH}", file=sys.stderr)
        sys.exit(2)

    with JSON_PATH.open("r", encoding="utf-8") as f:
        data = json.load(f)

    ap_list = locate_list(data)

    ints = []
    for i, x in enumerate(ap_list):
        try:
            xi = parse_strict_int(x, i)
        except ValueError as e:
            print("ERROR: BSD ap_table strict validation failed:", file=sys.stderr)
            print(str(e), file=sys.stderr)
            sys.exit(3)
        ints.append(xi)

    # convert to Lean literals
    lean_elems = [str(i) for i in ints]

    header = f"""-/- Auto-generated by Myproject/Python/emit_bsd_ap_table_strict.py
   Source JSON: {JSON_PATH}
   Generated: {datetime.datetime.utcnow().isoformat()} UTC
   STRICT MODE: the emitter failed if any entry was not an integer (or integer-string).
   DO NOT EDIT BY HAND â€” re-run the emitter to regenerate.
-/
"""

    body = "def ap_table : List Int := [" + ", ".join(lean_elems) + "]\n"

    out_text = header + "\nimport Mathlib.Data.Int.Basic\n\nnamespace Myproject\nnamespace BSD\n\n" + body + "\nend BSD\nend Myproject\n"

    OUT_PATH.parent.mkdir(parents=True, exist_ok=True)
    OUT_PATH.write_text(out_text, encoding="utf-8")
    print(f"Wrote {OUT_PATH} with {len(lean_elems)} integer entries (strict mode).")

if __name__ == "__main__":
    main()